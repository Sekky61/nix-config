#!/usr/bin/env bash
set -euo pipefail

readonly SCRIPT_NAME='record'
readonly VIDEO_DIR="${HOME}/Videos"
readonly CACHE_DIR="${XDG_CACHE_HOME:-${HOME}/.cache}"
readonly LOG_FILE="${CACHE_DIR}/record.log"
readonly STATE_FILE="${CACHE_DIR}/record.state"
readonly PIXEL_FORMAT='yuv420p'

notify() {
  local urgency="$1"
  local title="$2"
  local body="$3"

  if command -v notify-send >/dev/null 2>&1; then
    notify-send "$title" "$body" -a "$SCRIPT_NAME" -u "$urgency"
  fi
}

die() {
  local message="$1"
  notify critical 'Recording Error' "$message"
  printf '%s\n' "${SCRIPT_NAME}: ${message}" >&2
  exit 1
}

usage() {
  cat <<'EOF'
Usage: record [OPTION]

Start or stop a wf-recorder screen recording.
If a recording is already running, this command stops it.

Options:
  --sound             Record selected area with audio
  --fullscreen        Record full monitor without audio
  --fullscreen-sound  Record full monitor with audio
  --status            Print whether recording is active
  -h, --help          Show this help and exit
EOF
}

get_date_stamp() {
  date '+%Y_%m_%d'
}

random_words() {
  local -a adjectives=(
    amber brisk calm clever dusty eager fancy gentle hidden icy jolly kind lively
    misty nimble orbit primal quiet rapid solar tidy urban vivid windy young zesty
  )
  local -a nouns=(
    anchor beacon cedar comet delta ember forest harbor island junction kettle
    meadow north owl pepper quartz river summit thunder valley willow zephyr
  )

  printf '%s_%s\n' \
    "${adjectives[RANDOM % ${#adjectives[@]}]}" \
    "${nouns[RANDOM % ${#nouns[@]}]}"
}

get_output_file() {
  local base words candidate
  local suffix=1

  words="$(random_words)"
  base="$(get_date_stamp)_recording_${words}"
  candidate="${VIDEO_DIR}/${base}.mp4"

  while [[ -e "$candidate" ]]; do
    candidate="${VIDEO_DIR}/${base}_${suffix}.mp4"
    suffix=$((suffix + 1))
  done

  printf '%s\n' "$candidate"
}

has_running_recording() {
  pgrep -x wf-recorder >/dev/null 2>&1
}

save_state() {
  local output_file="$1"
  local pid="$2"
  printf 'output_file=%q\npid=%q\n' "$output_file" "$pid" >"$STATE_FILE"
}

clear_state() {
  rm -f "$STATE_FILE"
}

load_state_file() {
  local output_file=''
  local pid=''

  if [[ -f "$STATE_FILE" ]]; then
    # shellcheck source=/dev/null
    source "$STATE_FILE"
  fi

  printf '%s\n' "$output_file"
}

running_output_file_from_process() {
  local process_line path
  process_line="$(pgrep -a -x wf-recorder | sed -n '1p' || true)"

  if [[ "$process_line" =~ [[:space:]]-f[[:space:]]([^[:space:]]+) ]]; then
    path="${BASH_REMATCH[1]}"
    printf '%s\n' "$path"
  fi
}

default_audio_monitor() {
  local sink
  sink="$(pactl get-default-sink 2>/dev/null || true)"
  [[ -n "$sink" ]] || die 'Could not determine default PulseAudio sink'
  printf '%s.monitor\n' "$sink"
}

select_monitor() {
  local selected
  local -a monitors

  mapfile -t monitors < <(hyprctl monitors -j | jq -r '.[].name')

  if [[ ${#monitors[@]} -eq 0 ]]; then
    die 'No monitors reported by hyprctl'
  fi

  if [[ ${#monitors[@]} -eq 1 ]]; then
    printf '%s\n' "${monitors[0]}"
    return
  fi

  selected="$(printf '%s\n' "${monitors[@]}" | walker --dmenu --placeholder 'Select monitor' || true)"
  if [[ -z "$selected" ]]; then
    notify normal 'Recording Cancelled' 'No monitor selected'
    exit 130
  fi

  printf '%s\n' "$selected"
}

select_geometry() {
  local monitor="$1"
  local geometry

  geometry="$(slurp -o "$monitor" 2>/dev/null || true)"
  if [[ -z "$geometry" ]]; then
    notify normal 'Recording Cancelled' 'No area selected'
    exit 130
  fi

  printf '%s\n' "$geometry"
}

check_dependencies() {
  local mode="$1"
  local -a required=(wf-recorder jq hyprctl slurp walker)
  local -a missing=()
  local cmd

  if [[ "$mode" == 'area-sound' || "$mode" == 'fullscreen-sound' ]]; then
    required+=(pactl)
  fi

  for cmd in "${required[@]}"; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
      missing+=("$cmd")
    fi
  done

  if [[ ${#missing[@]} -gt 0 ]]; then
    die "Missing dependencies: ${missing[*]}"
  fi
}

stop_recording() {
  local output_file

  if ! has_running_recording; then
    clear_state
    notify normal 'Recording' 'No active recording found'
    return
  fi

  output_file="$(load_state_file)"
  if [[ -z "$output_file" ]]; then
    output_file="$(running_output_file_from_process || true)"
  fi

  pkill -INT -x wf-recorder || true

  for _ in {1..40}; do
    if ! has_running_recording; then
      clear_state
      if [[ -n "$output_file" ]]; then
        notify normal 'Recording Stopped' "Saved ${output_file##*/}"
      else
        notify normal 'Recording Stopped' 'Saved video file'
      fi
      return
    fi
    sleep 0.1
  done

  pkill -TERM -x wf-recorder || true
  clear_state
  if [[ -n "$output_file" ]]; then
    notify low 'Recording Stopped' "Forced stop, file: ${output_file##*/}"
  else
    notify low 'Recording Stopped' 'Forced stop after timeout'
  fi
}

start_recording() {
  local mode="$1"
  local monitor output_file geometry audio_monitor pid
  local -a cmd

  mkdir -p "$VIDEO_DIR" "$CACHE_DIR"

  monitor="$(select_monitor)"
  output_file="$(get_output_file)"

  cmd=(wf-recorder --pixel-format "$PIXEL_FORMAT" -f "$output_file" -o "$monitor")

  case "$mode" in
    area)
      geometry="$(select_geometry "$monitor")"
      cmd+=(--geometry "$geometry")
      ;;
    area-sound)
      geometry="$(select_geometry "$monitor")"
      audio_monitor="$(default_audio_monitor)"
      cmd+=(--geometry "$geometry" --audio="$audio_monitor")
      ;;
    fullscreen)
      ;;
    fullscreen-sound)
      audio_monitor="$(default_audio_monitor)"
      cmd+=(--audio="$audio_monitor")
      ;;
    *)
      die "Invalid recording mode: ${mode}"
      ;;
  esac

  nohup "${cmd[@]}" >>"$LOG_FILE" 2>&1 &
  pid=$!
  disown "$pid" 2>/dev/null || true

  sleep 0.2
  if ! kill -0 "$pid" >/dev/null 2>&1; then
    die "wf-recorder failed to start. See ${LOG_FILE}"
  fi

  save_state "$output_file" "$pid"

  notify normal 'Recording Started' "${output_file##*/} on ${monitor}"
}

print_status() {
  local output_file

  if has_running_recording; then
    output_file="$(load_state_file)"
    if [[ -z "$output_file" ]]; then
      output_file="$(running_output_file_from_process || true)"
    fi

    if [[ -n "$output_file" ]]; then
      printf 'live: %s\n' "${output_file##*/}"
    else
      printf 'live\n'
    fi
    return 0
  fi

  clear_state
  printf 'idle\n'
  return 1
}

parse_mode() {
  case "${1:-}" in
    '')
      printf '%s\n' 'area'
      ;;
    --sound)
      printf '%s\n' 'area-sound'
      ;;
    --fullscreen)
      printf '%s\n' 'fullscreen'
      ;;
    --fullscreen-sound)
      printf '%s\n' 'fullscreen-sound'
      ;;
    *)
      usage >&2
      die "Unknown option: ${1}"
      ;;
  esac
}

main() {
  local mode

  if [[ "${1:-}" == '-h' || "${1:-}" == '--help' ]]; then
    usage
    return
  fi

  if [[ "${1:-}" == '--status' ]]; then
    print_status
    return
  fi

  mode="$(parse_mode "${1:-}")"

  check_dependencies "$mode"

  if has_running_recording; then
    stop_recording
    return
  fi

  start_recording "$mode"
}

main "$@"
