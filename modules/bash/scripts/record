#!/usr/bin/env bash
set -euo pipefail

readonly SCRIPT_NAME='record'
readonly VIDEO_DIR="${HOME}/Videos"
readonly CACHE_DIR="${XDG_CACHE_HOME:-${HOME}/.cache}"
readonly LOG_FILE="${CACHE_DIR}/record.log"
readonly PIXEL_FORMAT='yuv420p'

notify() {
  local urgency="$1"
  local title="$2"
  local body="$3"

  if command -v notify-send >/dev/null 2>&1; then
    notify-send "$title" "$body" -a "$SCRIPT_NAME" -u "$urgency"
  fi
}

die() {
  local message="$1"
  notify critical 'Recording Error' "$message"
  printf '%s\n' "${SCRIPT_NAME}: ${message}" >&2
  exit 1
}

usage() {
  cat <<'EOF'
Usage: record [OPTION]

Start or stop a wf-recorder screen recording.
If a recording is already running, this command stops it.

Options:
  --sound             Record selected area with audio
  --fullscreen        Record full monitor without audio
  --fullscreen-sound  Record full monitor with audio
  -h, --help          Show this help and exit
EOF
}

get_timestamp() {
  date '+%Y%m%d_%H-%M-%S'
}

get_output_file() {
  printf '%s/recording_%s.mp4\n' "$VIDEO_DIR" "$(get_timestamp)"
}

has_running_recording() {
  pgrep -x wf-recorder >/dev/null 2>&1
}

default_audio_monitor() {
  local sink
  sink="$(pactl get-default-sink 2>/dev/null || true)"
  [[ -n "$sink" ]] || die 'Could not determine default PulseAudio sink'
  printf '%s.monitor\n' "$sink"
}

select_monitor() {
  local selected
  local -a monitors

  mapfile -t monitors < <(hyprctl monitors -j | jq -r '.[].name')

  if [[ ${#monitors[@]} -eq 0 ]]; then
    die 'No monitors reported by hyprctl'
  fi

  if [[ ${#monitors[@]} -eq 1 ]]; then
    printf '%s\n' "${monitors[0]}"
    return
  fi

  selected="$(printf '%s\n' "${monitors[@]}" | walker --dmenu --placeholder 'Select monitor' || true)"
  if [[ -z "$selected" ]]; then
    notify normal 'Recording Cancelled' 'No monitor selected'
    exit 130
  fi

  printf '%s\n' "$selected"
}

select_geometry() {
  local monitor="$1"
  local geometry

  geometry="$(slurp -o "$monitor" 2>/dev/null || true)"
  if [[ -z "$geometry" ]]; then
    notify normal 'Recording Cancelled' 'No area selected'
    exit 130
  fi

  printf '%s\n' "$geometry"
}

check_dependencies() {
  local mode="$1"
  local -a required=(wf-recorder jq hyprctl slurp walker)
  local -a missing=()
  local cmd

  if [[ "$mode" == 'area-sound' || "$mode" == 'fullscreen-sound' ]]; then
    required+=(pactl)
  fi

  for cmd in "${required[@]}"; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
      missing+=("$cmd")
    fi
  done

  if [[ ${#missing[@]} -gt 0 ]]; then
    die "Missing dependencies: ${missing[*]}"
  fi
}

stop_recording() {
  if ! has_running_recording; then
    notify normal 'Recording' 'No active recording found'
    return
  fi

  pkill -INT -x wf-recorder || true

  for _ in {1..40}; do
    if ! has_running_recording; then
      notify normal 'Recording Stopped' 'Saved video file'
      return
    fi
    sleep 0.1
  done

  pkill -TERM -x wf-recorder || true
  notify low 'Recording Stopped' 'Forced stop after timeout'
}

start_recording() {
  local mode="$1"
  local monitor output_file geometry audio_monitor pid
  local -a cmd

  mkdir -p "$VIDEO_DIR" "$CACHE_DIR"

  monitor="$(select_monitor)"
  output_file="$(get_output_file)"

  cmd=(wf-recorder --pixel-format "$PIXEL_FORMAT" -f "$output_file" -o "$monitor")

  case "$mode" in
    area)
      geometry="$(select_geometry "$monitor")"
      cmd+=(--geometry "$geometry")
      ;;
    area-sound)
      geometry="$(select_geometry "$monitor")"
      audio_monitor="$(default_audio_monitor)"
      cmd+=(--geometry "$geometry" --audio="$audio_monitor")
      ;;
    fullscreen)
      ;;
    fullscreen-sound)
      audio_monitor="$(default_audio_monitor)"
      cmd+=(--audio="$audio_monitor")
      ;;
    *)
      die "Invalid recording mode: ${mode}"
      ;;
  esac

  nohup "${cmd[@]}" >>"$LOG_FILE" 2>&1 &
  pid=$!
  disown "$pid" 2>/dev/null || true

  sleep 0.2
  if ! kill -0 "$pid" >/dev/null 2>&1; then
    die "wf-recorder failed to start. See ${LOG_FILE}"
  fi

  notify normal 'Recording Started' "${output_file##*/} on ${monitor}"
}

parse_mode() {
  case "${1:-}" in
    '')
      printf '%s\n' 'area'
      ;;
    --sound)
      printf '%s\n' 'area-sound'
      ;;
    --fullscreen)
      printf '%s\n' 'fullscreen'
      ;;
    --fullscreen-sound)
      printf '%s\n' 'fullscreen-sound'
      ;;
    *)
      usage >&2
      die "Unknown option: ${1}"
      ;;
  esac
}

main() {
  local mode

  if [[ "${1:-}" == '-h' || "${1:-}" == '--help' ]]; then
    usage
    return
  fi

  mode="$(parse_mode "${1:-}")"

  check_dependencies "$mode"

  if has_running_recording; then
    stop_recording
    return
  fi

  start_recording "$mode"
}

main "$@"
